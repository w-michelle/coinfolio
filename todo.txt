type Coin = {
  id: string;      // e.g., "bitcoin"
  symbol: string;  // e.g., "BTC"
  name: string;    // e.g., "Bitcoin"
  price: number;   // current price
};
User’s simulated portfolio

ts
Copy
Edit
type PortfolioItem = {
  coinId: string;
  amount: number;   // how much the user “owns”
  avgPrice: number; // average simulated purchase price
};

type Portfolio = PortfolioItem[];


3. Simulate Buy & Sell

Buy: Add to portfolio or increase amount if already exists.

Sell: Reduce amount, calculate realized gain/loss if you want.

function buyCoin(portfolio: Portfolio, coin: Coin, amountUsd: number): Portfolio {
  const existing = portfolio.find(item => item.coinId === coin.id);
  const quantity = amountUsd / coin.price;

  if (existing) {
    const totalCost = existing.avgPrice * existing.amount + amountUsd;
    const totalAmount = existing.amount + quantity;
    existing.avgPrice = totalCost / totalAmount;
    existing.amount = totalAmount;
    return [...portfolio];
  }

  return [...portfolio, { coinId: coin.id, amount: quantity, avgPrice: coin.price }];
}

function sellCoin(portfolio: Portfolio, coin: Coin, quantity: number): Portfolio {
  return portfolio.map(item => {
    if (item.coinId === coin.id) {
      return { ...item, amount: Math.max(item.amount - quantity, 0) };
    }
    return item;
  }).filter(item => item.amount > 0);
}



import {
  pgTable,
  serial,
  uuid,
  varchar,
  decimal,
  timestamp,
  integer,
} from "drizzle-orm/pg-core";
import { relations } from "drizzle-orm";

// ---------------- USERS ----------------
export const users = pgTable("users", {
  id: uuid("id").defaultRandom().primaryKey(),
  email: varchar("email", { length: 255 }).notNull().unique(),
  createdAt: timestamp("created_at").defaultNow(),
});

// ---------------- PORTFOLIOS ----------------
export const portfolios = pgTable("portfolios", {
  id: serial("id").primaryKey(),
  userId: uuid("user_id").notNull().references(() => users.id),
  cash: decimal("cash", { precision: 18, scale: 2 }).default("0"),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

// ---------------- HOLDINGS ----------------
export const holdings = pgTable("holdings", {
  id: serial("id").primaryKey(),
  portfolioId: integer("portfolio_id").notNull().references(() => portfolios.id),
  symbol: varchar("symbol", { length: 20 }).notNull(), // e.g. "bitcoin"
  quantity: decimal("quantity", { precision: 18, scale: 8 }).default("0"),
  avgBuyPrice: decimal("avg_buy_price", { precision: 18, scale: 2 }).default("0"),
});

// ---------------- TRANSACTIONS ----------------
export const transactions = pgTable("transactions", {
  id: serial("id").primaryKey(),
  portfolioId: integer("portfolio_id").notNull().references(() => portfolios.id),
  type: varchar("type", { length: 20 }).notNull(), // "buy" | "sell" | "deposit" | "withdraw"
  symbol: varchar("symbol", { length: 20 }), // only needed for buy/sell
  quantity: decimal("quantity", { precision: 18, scale: 8 }), // how much coin
  price: decimal("price", { precision: 18, scale: 2 }), // price per coin at transaction
  amountUsd: decimal("amount_usd", { precision: 18, scale: 2 }).notNull(), // total transaction value
  createdAt: timestamp("created_at").defaultNow(),
});

// ---------------- RELATIONS ----------------
export const usersRelations = relations(users, ({ many }) => ({
  portfolios: many(portfolios),
}));

export const portfoliosRelations = relations(portfolios, ({ one, many }) => ({
  user: one(users, {
    fields: [portfolios.userId],
    references: [users.id],
  }),
  holdings: many(holdings),
  transactions: many(transactions),
}));

export const holdingsRelations = relations(holdings, ({ one }) => ({
  portfolio: one(portfolios, {
    fields: [holdings.portfolioId],
    references: [portfolios.id],
  }),
}));

export const transactionsRelations = relations(transactions, ({ one }) => ({
  portfolio: one(portfolios, {
    fields: [transactions.portfolioId],
    references: [portfolios.id],
  }),
}));